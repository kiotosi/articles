# Svelte

**Svelte** - веб-фреймворк, который отличается принципом работы от React и Vue. React и Vue выполняют сборку проекта прям в браузере, когда пользователь открывает необходимый ему ресурс, Svelte же заранее компилирует исходный код и гидрирует приложение, благодаря чему код получается быстрый, простой и надежный.

У Svelte нет Virtual DOM, то есть он напрямую работает с DOM в браузере и изменяет его по мере необходимости.

# Установка

Использовать сам фреймворк можно с помощью нескольких способов:

- С помощью Vite
  
- С помощью `npm create svelte@latest`
  

# Синтаксис

Каждый компонент в Svelte - SFC (Single File Component).

Как и во Vue внутри SFC можно разместить:

- Стили
- Верстку
- Логику
  

```svelte
<script>
	// Здесь идет логика (JS)
</script>

<!-- Здесь идет размeтка (HTML) -->

<style>
	/* Здесь идут стили (CSS) */
</style>
```

Все что находится внутри `<script>` выполняется во время создания компонента.

Внутри `<script>` также есть дополнительные правила, которые будет рассмотрены ниже. Важно помнить что svelte - фреймворк, который компилирует исходный код, а значит у Svelte может быть дополнительные значения у привычных для нас вещей (напр. `export`, [который описан ниже](#пропсы))

# Состояния
Состояния внутри Svelte объявляются с помощью let и const. Все верно, каждая переменная объявленная в глобальном скоупе является состоянием.

> **На случай, если это ваш первый реактивный фреймворк**:
> 
> Состояния нужны для обновления интерфейса. Как только состояние обновляется - обновляется и интерфейс приложения, который показывает актуальные данные.

```svelte
<script>
// Новое состояние name
let name = 'Daniil';

// Новое неизменяемое состояние
const age = 20;
</script>
```

# Шаблон
Шаблон компонента можно писать прямо в файле `.svelte`:

```svelte
<script>
  let name = 'Daniil';
</script>

<div>
  <!-- Здесь находится какая-то верстка -->
</div>
```

## Интерполяция
Для того чтобы использовать состояния внутри шаблона нужно укзаать на имя состояния в фигурных скобках:

```svelte
<script>
// Состояние, которое хранит имя
const name = 'Daniil';
</script>

<h1>Hello, { name }</h1>
<!-- Выведется: Hello, Daniil -->
```

Мы также можем использовать методы JS, для того чтобы взаимодействовать с состоянием прямо внутри скобок для интерполяции:

```svelte
<script>
const age = 20;
</script>

<div>
  <h1>Пользователь старше 18 лет?</h1>
  <span>{ age > 18 }</span> <!-- true -->
</div>
```

## Атрибуты
Интерполяция работает с атрибутами точно также, как и с текстом внутри элемента:

```svelte
<script>
const imageSource = '/img/1.jpg';
</script>

<img src={src} alt="Default image alt">
<!-- или -->
<img {src} alt="Default image alt">
```

# Импортирование компонентов
# Пропсы

> **Пропсы** - данные, которые компонент берет из родительского компонента. Пропсы передаются как атрибут при использовании компонента.

С помощью ключевого слова `export` мы можем объявлять пропсы (по сути просто экспортируя переменную):

```svelte
<!-- Hello.svelte -->
<script>
  export let name = 'John';
</script>

<div>
  Hello, { name }
</div>
```

Когда мы будем использовать компонент `Hello.svelte` - мы будем передавать имя через `name="значение"`. Если мы не передадим значение, то будет использоваться значение, с которым переменная `name` инициализировалась (`John`).

```svelte
<!-- App.svelte -->
<script>
  import Hello from './Hello.svelte';
</script>

<div>
  <!-- Выведется "Hello, Daniil" -->
  <Hello name="Daniil" /> 

  <!-- Выведется "Hello, John", ибо мы не передали пропс -->
  <Hello /> 
</div>
```

> **Важно**
>
> Нужно обязательно инициализировать пропс с дефолтным значением (даже если это `undefined`). Если мы просто напишем
> ```svelte
> <script>
> export let foo;
> </script>
> ```
> то svelte будет жаловаться.

<!--
  TODO: Написать про [export const; export function]
-->

# Реактивность
Все переменные которые объявлены внутри `<script>` по умолчанию являются реактивными.

То есть, если мы инициализируем переменную для счетчика, которая будет отображать число кликов и с помощью метода прибавим к ней 1, то значение сразу же отрисуется в верстке:

```svelte
<script>
let counter = 0;

function increment() {
  counter += 1;
}
</script>

<div on:click={increment}>
  { counter }
</div>
```

> Если вас смущает `on:click={}`, то не стоит сейчас об этом думать, мы рассмотрим привязку ивентов чуть позже. Если вкратце, то тут мы привязываем на клик функцию `increment`.

## Основы реактивности
Реактивность в svelte основана на присвоении переменной значения. Это значит что при использовании методов, которые так или иначе меняют значения структуры (напр. массива) svelte не будет триггерить ререндер (обновления интерфейса).

```svelte
<script>
let foodList = [];

// Данный метод __не__ вызовет перерисовку
function lostRender() {
  foodList.push('Milk');
}

// Данный метод вызовет перерисовку
function niceRender() {
  foodList = [...foodList, ''];
}
</script>
```

В примере вверху функция `lostRender` не затриггерит перерисовку, так как мы используем встроенный метод для того чтобы обновить массив.

Функция `niceRender` перерисует значения на странице, так как мы присваиваем новое значение переменой `foodList`.

## Обновление значений
Блок `<script>` внутри компонента выполняется полностью только однажды (при создании компонента). Это значит что после того как компонент примонтируется, внутренние состояния, которые зависят от пропсов не будут обновляться:

```svelte
<script>
export let name = '';
let uppercaseName = name.toUpperCase();
</script>
```

Если мы используем компонент и в процессе взаимодействия с интерфейсом пользователь изменит имя, которое передается в пропс компонента вверху, то переменная `uppercaseName` не обновится (хоть `name` и обновится), так как весь код был выполнен при создании компонента.

# Прослушиватели, они же watchers

Прослушиватели в Svelte сделаны с помощью [лэйблов в JS](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label). Для реактивного блока создан специальный лэйбл `$`.

После `$` могут идти фигурные скобки или название переменной, в зависимости от которых будет меняться контекст (см. далее).

## Наблюдатель
В случае с фигурными скобками - блок будет выполняться каждый раз, когда задействованные переменные в нем обновляются:

```svelte
<script>
let counter = 0;

function incrementCounter() {
  counter += 1;
}

$: {
  // Будет выполняться каждый раз, как переменная counter будет обновляться
  console.log('Счетчик поменялся!', counter);
}

</script>

<h1 on:click={incrementCounter}>Счетчик: { counter }</h1>
```

## Вычисляемое значение
В случае если после `$` будет идти присвоение - то новая переменная будет обновлять свое значение каждый раз, как реактивная переменная которая учавствует в присвоении была обновлена.

В ["Обновлении значений"](#обновление-значений) мы говорили о том, что при инициализации переменной с помощью пропса - она не будет меняться, даже если значение пропса изменилось. Это можно исправить с помощью вычисляемого значения. Сделать так, чтобы переменная пересчитывалась каждый раз, как меняется пропс можно следующим образом:

```svelte
<script>
export let name = '';
$: uppercaseName = name.toUpperCase();
</script>
```

> Нужно обратить внимание, что перед `uppercaseName` не используется `let`.

### Для тех, кто знает Vue или React
Если сравнивать с Vue или React, то `$` похож на `computed` и `watch`:

```svelte
<script>
// Аналог computed
let activeId = 1;
$: activeIdText = `Current active id: ${activeId}`;

// Аналог watch
$: {
  console.log('activeId пересчитался!', activeId);
}
</script>
```

